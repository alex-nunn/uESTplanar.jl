var documenterSearchIndex = {"docs":
[{"location":"examples/02_potential_fields/#2.-Electrostatic-fields","page":"Potential fields","title":"2. Electrostatic fields","text":"","category":"section"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"Consider a planar electrostatic trap of infinite extent with electrodes at  z = 0 and z = 1. If the potential on the bottom electrode z=0 is given by a Dirac-delta distribution at x=0 y=0 then the potential in the interior of the electrostatic trap is given by the kernel K(x y z).","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"If the potential on the bottom electrode is given by f(xy) we can compute the electrostatic field in the trap using a 2-dimensional convolution over the x and y coordinates,","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"phi(x y z) = iint  K(x - x y - y z) f(xy) dx dy","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"where 0  z  1. If the potentials on the top and bottom plates are identical then we can add the contribution of each plate as,","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"phi(x y z) = iint  left ( K(x - x y - y z) + K(x - x y - y 1 - z) right ) f(xy) dx dy","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"where 0  z  1. ","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"We can use the KernelConvolution type to perform this 2-dimensional convolution as follows.","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"using Plots\nusing Plots.Measures\nusing uESTplanar\n\n# 1. Define convolution kernel\nz = 0.5  # midplane of the electrostatic trap\nkconv = KernelConvolution(\n    range(-5, 10; step=0.005),\n    range(-5, 5; step=0.005),\n    (x, y)-> K(x, y, z) + K(x, y, 1 - z)\n)\n\n# 2. Define a potential function with a wavy boundary\nx0 = 0.0  # position of interface\nλ = 2.0  # wavelength of variation\nA = 2.0   # amplitude of variation\nwavy_boundary = (x, y) -> (A * cos(2π / λ * y) < x - x0) ? 1.0 : 0.0\n\n# 3. Compute potential over grid of convolution\nboundary_matrix = wavy_boundary.(kconv.xs, kconv.ys')\n\n# 4. Apply convolution operator\npotential = kconv(boundary_matrix)\n\n# 5. Plot potential\n(; xs, ys) = kconv\npkws = (\n    xlabel=\"x\",\n    ylabel=\"y\",\n    xlims=(-5, 10),\n    ylims=(-5, 5),\n    size=(600, 400),\n    colorbar=false,\n    margin=5mm,\n)\n\np1 = heatmap(\n    xs, ys, transpose(boundary_matrix);\n    title=\"boundary potential\",\n    pkws...\n)\n\np2 = heatmap(\n    xs, ys, transpose(potential);\n    title=\"midplane potential\",\n    pkws...\n)\n\np = plot(p1, p2; layout=(1, 2), size=(1000, 400))\nsavefig(\"02_potential_example.png\"); nothing # hide","category":"page"},{"location":"examples/02_potential_fields/","page":"Potential fields","title":"Potential fields","text":"(Image: )","category":"page"},{"location":"examples/01_convolutions/#1.-Convolutions-in-2D-dimensions","page":"Convolutions","title":"1. Convolutions in 2D dimensions","text":"","category":"section"},{"location":"examples/01_convolutions/","page":"Convolutions","title":"Convolutions","text":"The KernelConvolution type allows us to rapidly convolve 2-dimensional functions with a kernel function. ","category":"page"},{"location":"examples/01_convolutions/","page":"Convolutions","title":"Convolutions","text":"For example, we can convolve the 2-dimensional box function f(x y) with a Gaussian kernel using the following code.","category":"page"},{"location":"examples/01_convolutions/","page":"Convolutions","title":"Convolutions","text":"using Plots\nusing uESTplanar\n\n# 1. Define convolution kernel\nσ = 0.3\nkconv = KernelConvolution(\n    range(-2, 2; step=0.005),\n    range(-2, 2; step=0.005),\n    (x, y)-> exp(-(x^2 + y^2) / (2σ^2)) / (sqrt(2π) * σ)\n)\n\n# 2. Define box function & compute over grid\nf = (x, y) ->  -1 < x < 1 && -1 < y < 1 ? 1.0 : 0.0\n(; xs, ys) = kconv\nboundary_values = f.(xs, ys')\n\n# 3. Apply kernel transform\nresult = kconv(boundary_values)\n\n# 4. Plot potential\nheatmap(\n    xs, ys, transpose(result);\n    xlabel=\"x\",\n    ylabel=\"y\",\n    size=(450, 450),\n    aspect_ratio=:equal,\n    dpi=100\n)\nsavefig(\"01_convolution_example.png\"); nothing # hide","category":"page"},{"location":"examples/01_convolutions/","page":"Convolutions","title":"Convolutions","text":"(Image: )","category":"page"},{"location":"examples/01_convolutions/","page":"Convolutions","title":"Convolutions","text":"The Fast Fourier Transform (FFT) used to perform the 2-dimensional convolution is faster on arrays where the length is a power of two. We can sometimes increase evaluation speed by rounding our grid size to the nearest power of two using the round_pow2 method.","category":"page"},{"location":"examples/01_convolutions/","page":"Convolutions","title":"Convolutions","text":"For example,","category":"page"},{"location":"examples/01_convolutions/","page":"Convolutions","title":"Convolutions","text":"using uESTplanar\n\n# Kernel\nσ = 0.3\nkernel = (x, y)-> exp(-(x^2 + y^2) / (2σ^2)) / (sqrt(2π) * σ)\n\n# Grid\nxs = range(-2.5, 2.5; step=0.005)\nxs_pow2 = round_pow2(xs)\n\n# Convolutions\nkc1 = KernelConvolution(xs, xs, kernel)\nkc2 = KernelConvolution(xs_pow2, xs_pow2, kernel)\n\n# Random boundary potentials\nfs1 = randn(size(kc1)...)\nfs2 = randn(size(kc2)...)\n\n# Compare evaluation speeds\nt1 = @timed kc1(fs1)\nt2 = @timed kc2(fs2)\n\nprintln(\"normal grid : $(t1.time) sec\")\nprintln(\"power 2 grid : $(t2.time) sec\")","category":"page"},{"location":"examples/04_ion_trajectories/#4.-Ion-trajectories","page":"Ion trajectories","title":"4. Ion trajectories","text":"","category":"section"},{"location":"examples/04_ion_trajectories/","page":"Ion trajectories","title":"Ion trajectories","text":"In this example we compute the trajectories of ions in a planar electrostatic trap.","category":"page"},{"location":"examples/04_ion_trajectories/","page":"Ion trajectories","title":"Ion trajectories","text":"using Plots\nusing Plots.Measures\nusing uESTplanar\nusing DifferentialEquations\nusing Interpolations\n\n# Useful function\n\"\"\"\n    square_wave(x, α)\n\nReturn the value of a square wave at `x` with duty-cycle `α` and unit period.\n\"\"\"\nfunction square_wave(x, α)\n    mod(x + 0.5α, 1.0) < α ? 1.0 : 0.0\nend\n\n# Define electric field component of interest\nz = 0.5\nxs = range(-10, 10; step=0.01)\nys = range(-5, 5; step=0.01)\n\nker_pot = KernelConvolution(\n    xs,\n    ys,\n    (x, y) -> K(x, y, z) + K(x, y, 1 - z)\n)\n\nker_Ef = KernelConvolution(\n    xs,\n    ys,\n    (x, y) -> [\n        -∂xK(x, y, z) - ∂xK(x, y, 1 - z),\n        -∂yK(x, y, z) - ∂yK(x, y, 1 - z)\n    ],\n    2\n)\n\n# Define the boundary potential\nλ = 1\nduty_cycle = x -> clamp(abs(x / 6) - 0.25, 0.1, 0.9)\nf = (x, y) -> square_wave(y / λ, duty_cycle(x))\nfmat = f.(ker_Ef.xs, ker_Ef.ys')\n\n# Compute potential & electric fields\npot_mat = ker_pot(fmat)\nE_field_mat = ker_Ef(fmat)\n\n# Interpolate\npot_interp = cubic_spline_interpolation((xs, ys), pot_mat)\nEx_interp = cubic_spline_interpolation((xs, ys), E_field_mat[:, :, 1])\nEy_interp = cubic_spline_interpolation((xs, ys), E_field_mat[:, :, 2])\n\n# Define ODE function\nfunction F(du, v, u, p, t)\n    x, y = u\n    du[1] = Ex_interp(x, y)\n    du[2] = Ey_interp(x, y)\nend\n\n# Define callback to terminate ODE when the ion is out of bounds\ncb = VectorContinuousCallback(\n    (out, u, t, integrator) -> begin\n        x = u[3]\n        y = u[4]\n\n        margin = 0.2\n        out[1] = x - (xs[begin] + margin)\n        out[2] = x - (xs[end] - margin)\n        out[3] = y - (ys[begin] + margin) \n        out[4] = y - (ys[end] - margin)\n    end,\n    (integrator, idx) -> terminate!(integrator),\n    4\n)\n\n# Define & solve ODE problem\nu0 = [0.0, 0.2]\ndu0 = [1, 0.0]\ntspan = (0.0, 500.0)\nprob = SecondOrderODEProblem(F, du0, u0, tspan, callback=cb)\nsol = solve(prob, DPRKN6())\n\n# Compute ODE solution for a range of different times\nts = range(tspan..., 1000)\npos = stack(sol(t)[3:4] for t ∈ ts)\nnothing # hide","category":"page"},{"location":"examples/04_ion_trajectories/","page":"Ion trajectories","title":"Ion trajectories","text":"pkws = (\n    xlabel=\"x\", \n    xlims=(-10, 10),\n    ylims=(0, 1),\n    frame=:box,\n    label=false,\n    margin=3mm\n)\n\np1 = plot(\n    xs, duty_cycle.(xs);\n    title=\"duty cycle\",\n    ylabel=\"α(x)\",\n    pkws...\n)\np2 = plot(\n    xs, pot_interp.(xs, 0.0);\n    title=\"midline potential\",\n    ylabel=\"ϕ(x)\",\n    pkws...\n)\np = plot(p1, p2; layout=(1, 2), size=(1000, 400), margin=5mm)\nsavefig(p, \"04_01_duty_cycle.png\")\n\npkws = (\n    xlabel=\"x\", \n    ylabel=\"y\",\n    xlims=(-10, 10),\n    ylims=(-3, 3),\n    colorbar=:none,\n    frame=:box,\n    label=false,\n)\n\np1 = heatmap(\n    xs, ys, transpose(fmat);\n    title=\"boundary potential\",\n    pkws... \n\n)\n\np2 = heatmap(\n    xs, ys, transpose(pot_mat);\n    title=\"midplane potential\",\n    pkws...\n)\n\nplot!(\n    p2,\n    pos[1, :], pos[2, :],\n    linecolor=:white,\n    linewidth=1,\n    label=false\n)\n\np = plot(\n    p1, p2; \n    layout=(1, 2), \n    size=(1000, 400),\n    margin=5mm\n)\nsavefig(p, \"04_02_trajectory.png\")","category":"page"},{"location":"examples/04_ion_trajectories/","page":"Ion trajectories","title":"Ion trajectories","text":"(Image: )","category":"page"},{"location":"examples/04_ion_trajectories/","page":"Ion trajectories","title":"Ion trajectories","text":"(Image: )","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#convolutions","page":"Reference","title":"convolutions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"KernelConvolution\nKernelConvolution{T}(::StepRangeLen{T}, ::StepRangeLen{T}, ::Any, ::Any) where {T}\nBase.size(::KernelConvolution)\nround_pow2","category":"page"},{"location":"reference/#uESTplanar.KernelConvolution","page":"Reference","title":"uESTplanar.KernelConvolution","text":"KernelConvolution{T, M}\n\nConvolution kernel type contains a grid information and the kernel convolution matrix. Instances of KernelConvolution can be used to convolve 2-dimensional functions.\n\nThe convolution is zero-padded and the type also allocates a buffer allowing the kernel transform to be applied many times with minimal memory usage.\n\nTypes\n\nT<:AbstactFloat floating point precision type\nM::Int dimension of kernel function. For scalar kernals M =1, for vector    kernels M = 3\n\nProperties\n\nxs::StepRangeLen{T} grid of x values in cartesian grid\nys::StepRangeLen{T} grid of y values in cartesian grid\nkermat::Array{Complex{T}} M-dimensional Fourier space kernel matrix\nbuffer::Array{Complex{T}} M-dimensional buffer\n\n\n\n\n\n","category":"type"},{"location":"reference/#uESTplanar.KernelConvolution-Union{Tuple{T}, Tuple{StepRangeLen{T}, StepRangeLen{T}, Any, Any}} where T","page":"Reference","title":"uESTplanar.KernelConvolution","text":"KernelConvolution{T}(xs, ys, kernel, M=1)\n\nConstruct a kernel convolution over grid xs, ys using kernel(x, y) function. The M specifies the dimension of the kernel function output.\n\nFor example, if the kernel is scalar function then kernel(x, y) should return a scalar value and M = 1. If the kernel is a vector function where kernel(x,y) outputs a vector of length n then M = n.\n\nExamples\n\nDefining a 2-dimensional kernel function\n\njulia> kernel = (x, y) -> [cos(x), sin(y)];\njulia> xs = range(0, 1, 128)\njulia> KernelConvolution{Float64}(xs, xs, kernel, 2);\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.size-Tuple{KernelConvolution}","page":"Reference","title":"Base.size","text":"size(kconv::KernelConvolution{T, M})\n\nReturn the size of the convolution grid\n\n\n\n\n\n","category":"method"},{"location":"reference/#uESTplanar.round_pow2","page":"Reference","title":"uESTplanar.round_pow2","text":"round_pow2(n::Integer)\n\nRound an integer to the nearest power of two.\n\nExamples\n\njulia> round_pow2(4)\n4\njulia> round_pow2(5)\n4\n\n\n\n\n\nround_pow2(xs::AbstractRange)\n\nModify the step size so the range length is the nearest power of two.\n\nExamples\n\njulia> xs = 1:7;\njulia> round_pow2(xs)\n1:1:8\n\n\n\n\n\n","category":"function"},{"location":"reference/#kernels","page":"Reference","title":"kernels","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"K\n∂xK\n∂yK\n∂zK","category":"page"},{"location":"reference/#uESTplanar.K","page":"Reference","title":"uESTplanar.K","text":"K(x, y, z)\n\nPlanar electrostatic trap kernel in cartesian coordinates where 0 < z < 1 and x, y are real valued horizontal coordinates. The bottom and top plates of the trap are located at z = 0 and z = 1, respectively.\n\nUseful for computing the electrostatic field via convolution.\n\nSee also ∂xK, ∂yK, ∂zK.\n\n\n\n\n\nK(ρ, z)\n\nPlanar electrostatic trap kernel in cylindrical coordinates where 0 < ρ, 0 < z < 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#uESTplanar.∂xK","page":"Reference","title":"uESTplanar.∂xK","text":"∂xK(x, y, z)\n\nPartial derivative wrt. x of planar electrostatic trap kernel in cartersian  coordinates where 0 < z < 1.\n\nSee also K\n\n\n\n\n\n","category":"function"},{"location":"reference/#uESTplanar.∂yK","page":"Reference","title":"uESTplanar.∂yK","text":"∂yK(x, y, z)\n\nPartial derivative wrt. y of planar electrostatic trap kernel in cartersian  coordinates where 0 < z < 1.\n\nSee also K\n\n\n\n\n\n","category":"function"},{"location":"reference/#uESTplanar.∂zK","page":"Reference","title":"uESTplanar.∂zK","text":"∂zK(x, y, z)\n\nPartial derivative wrt. z of planar electrostatic trap kernel in cartersian  coordinates where 0 < z < 1.\n\nSee also K\n\n\n\n\n\n","category":"function"},{"location":"examples/03_electric_fields/#3.-Electric-fields","page":"Electric fields","title":"3. Electric fields","text":"","category":"section"},{"location":"examples/03_electric_fields/","page":"Electric fields","title":"Electric fields","text":"We can also compute the electric field using convolutions. If the potential on the bottom plate, z = 0, is given by f(xy) then the electric field has the form,","category":"page"},{"location":"examples/03_electric_fields/","page":"Electric fields","title":"Electric fields","text":"beginaligned\nE = - nabla phi(x y z)\n= -nablaiint K(x - x y - y z) f(x y) dxdy \nendaligned","category":"page"},{"location":"examples/03_electric_fields/","page":"Electric fields","title":"Electric fields","text":"The uESTplanar module provides the partial derivatives of the kernel function K(x y z) with respect to each cartesian coordinate as ∂xK,  ∂yK, ∂zK. The example below shows how to use these functions to compute the electric field.","category":"page"},{"location":"examples/03_electric_fields/","page":"Electric fields","title":"Electric fields","text":"using Plots\nusing Plots.Measures\nusing LaTeXStrings\nusing uESTplanar\n\n# 1. Define kernel for each electric field component\nz = 0.25\nkconv = KernelConvolution{Float32}(\n    range(-5, 10; step=0.01f0),\n    range(-5, 5; step=0.01f0),\n    (x, y)-> [\n        -∂xK(x, y, z) - ∂xK(x, y, 1 - z),\n        -∂yK(x, y, z) - ∂yK(x, y, 1 - z),\n        -∂zK(x, y, z) + ∂zK(x, y, 1 - z),\n    ],\n    3\n)\n\n# 2. Define a potential function with a wavy boundary\nx0 = 0.0  # position of interface\nλ = 2.0  # wavelength of variation\nA = 2.0   # amplitude of variation\nwavy_boundary = (x, y) -> (A * cos(2π / λ * y) < x - x0) ? 1.0f0 : 0.0f0\n\n# 3. Compute potential over grid of convolution\nboundary_matrix = wavy_boundary.(kconv.xs, kconv.ys')\n\n# 4. Apply convolution operator\nelectric_field = kconv(boundary_matrix)\n\n# 5. Plot potential\n(; xs, ys) = kconv\npkws = (\n    xlabel=\"x\",\n    ylabel=\"y\",\n    xlims=(-5, 10),\n    ylims=(-5, 5),\n    size=(600, 400),\n    colorbar=false,\n    margin=3mm,\n)\n\np1 = heatmap(\n    xs, ys, transpose(boundary_matrix);\n    title=\"boundary potential\",\n    pkws...\n)\n\nps = [\n    heatmap(\n        xs, ys, transpose(electric_field[:, :, i]);\n        title=L\"E_%$label\",\n        titlefontsize=16,\n        pkws...\n    )\n    for (i, label) ∈ enumerate(\"xyz\")\n]\n\n\np = plot(p1, ps...; layout=(2, 2), size=(800, 800))\nsavefig(\"03_electric_example.png\"); nothing # hide","category":"page"},{"location":"examples/03_electric_fields/","page":"Electric fields","title":"Electric fields","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = uESTplanar","category":"page"},{"location":"#uESTplanar","page":"Home","title":"uESTplanar","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for rapidly computing the electrostatic field within planar ion traps. The source code can be found in the github repository uESTplanar.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package requires Julia >= 1.10","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed in a Julia environment using the command,","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/alex-nunn/uESTplanar.jl.git\")","category":"page"}]
}
